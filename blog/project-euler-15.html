<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>mntn.dev - Project Euler Problem #15</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/5e367c032bdf8114c40f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5e367c032bdf8114c40f.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-b0c7974219aef92009e3.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.e2fe4ae6b85b1c7a6eb1.js" as="script"/><link rel="preload" href="/_next/static/chunks/54b56f31e4a63390429c9c080bc5921c15532dc8.bd079db40d49792afdb6.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-8e54f29680ba8022333b.js" as="script"/><link rel="preload" href="/_next/static/chunks/9c82dd96d47f7e65c3cc5f64ff6b92c39ae32daa.9fed936b4ac0e3903de0.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5BpostId%5D-f2c0fc5138d8706d07d3.js" as="script"/></head><body><div id="__next"><div><nav><div class="wrapper"><div class="header-wrapper"><div class="header-col"><a href="/"><svg class="logo-container" viewBox="0 0 12.4355 5.8209889"><g transform="translate(-1.0582919,-1.0582557)"><path class="logo" d="m 1.9843752,5.953161 3.96875,-3.9688494 2.6458334,2.6458994 1.3229163,-1.32295 2.6458331,2.6459" id="path862"></path></g></svg></a></div><div class="header-col"><a href="/about">About</a><a href="/blog">Blog</a></div></div></div></nav><div class="content"><div class="wrapper"><div><div class="backline"><a href="/blog"><h1>&lt;</h1></a><h1>Project Euler Problem #15</h1></div><br/><em>Fri Nov 13 2020</em><div class="markdown-container"><p><em>Doing the right things the wrong way.</em></p>
<h1>Intro</h1>
<p><a href="https://projecteuler.net/problem=15">Problem #15</a> from <a href="https://projecteuler.net/about">Project Euler</a> is a really interesting problem. Not only is there a clean mathematical solution to the question, but there are a <em>bunch</em> of non-optimal (or even downright ugly) but intuitive ways to solve the problem.</p>
<h1>The Easy Way</h1>
<p>The easiest, and probably fastest, way to solve this problem is to just use math. Consider the rules of the problem:</p>
<ol>
<li>Each path is composed of <em>2N</em> steps that lead from the top left to the bottom right of the domain.</li>
<li>Each step can only be a rightward or downward move.</li>
<li>Because of the start and end positions, each path must have an equal number of down and right moves.</li>
</ol>
<p>Based on these rules, you can build a valid path by starting with an empty list of <em>2N</em> steps, selecting <em>N</em> steps to place a rightward move, and filling the remaining steps with downward moves. This is a <a href="https://en.wikipedia.org/wiki/Combination">Combination Problem</a>! The number of valid paths you can possibly construct is <em>2N choose N</em>.</p>
<h1>A Fun Way</h1>
<p><center><img src="/img/treediagram.png"/></center></p>
<p>Maybe you&#x27;re itching for a reason to think about binary trees. You can look at every step in a path as a node in a binary tree. The starting position is the root node. The root node has two child nodes, one for a downward move and one for a rightward move. Each of those nodes have their own children in the same pattern. This means that two of the &quot;grandchild&quot; nodes actually describe different paths to the same point. In the above picture, downward moves are to the left and rightward to the right.</p>
<p>Using this tree, we can describe any path on an infinite grid. To constrain the grid (and know when we&#x27;ve reached the end point), we need to add some state to each node: an x and y position: (x,y). To create a new downward node in our domain, y must be less than <em>N</em> - the new node&#x27;s y value will be increased by 1. To create a new rightward node, x must be less than <em>N</em> - we&#x27;ll increase the node&#x27;s x. If a new node has state <em>x == N</em> and <em>y == N</em>, we&#x27;ve hit the end point of the grid!</p>
<p>If we actually build out this tree to full <em>2N</em> depth, we&#x27;ll eat up a ton of memory. Conveniently, we don&#x27;t actually need to hold all of this state since we&#x27;re only interested in how many nodes in the tree are at the end point. We can just pretend to build the tree with a recursive function. Here&#x27;s an implementation in RustðŸ¦€:</p>
<pre><code>// The size of our domain in steps
// The grid is NxN steps
// Really, our position grid is N+1xN+1
// [0,0] describes the start and [N,N] describes the end point
static N:u32 = 20;

fn build_node(x:u32, y:u32, n_ends:&amp;mut u64) {
    // If x==y==N, we&#x27;re at the end point!
    if x == N &amp;&amp; y == N {
        *n_ends += 1;
        return;
    }
    // Recurse for each child node if possible
    if x &lt; N {
        build_node(x + 1, y, n_ends);
    }
    if y &lt; N {
        build_node(x, y + 1, n_ends);
    }
}

fn main() {
    let mut n_ends:u64 = 0;
    // This describes the root node
    build_node(0, 0, &amp;mut n_ends);
    println!(&quot;Total unique paths: {}&quot;, n_ends);
}
</code></pre>
<p>Go get a coffee or two, because this took ~30min to run on my machine.</p>
<p><em>Edit: This can be heavily optimized without abandoning the tree structure! More info in <a href="/blog/project-euler-15-addendum">this more recent post</a>.</em></p>
<h1>An ugly way</h1>
<p>Suppose you were told to solve this problem on an FPGA and you have <em>no clue</em> what combination is. Since we know the length of a path is <em>2N</em>, we&#x27;ll start with a <em>2N</em>-bit wide counter. Let&#x27;s say down = 1 and right = 0. We can initialize a down-counter with all 1s and let it run all the way down to 0. Since we know a valid path has #rights=#downs=<em>N</em>, we&#x27;ll look at every counter value and keep track of the number of values which have exactly <em>N</em> ones. That number is the number of possible paths!</p>
<p>We can even slightly optimize this by recognizing that we only have to evalute all of the paths that start with a downward move and multiply the result by two. This follows from our tree representation above. Rust example below:</p>
<pre><code>// The size of our domain in steps
static N:u32 = 20;

fn main() {
    let n_ends:u64 = (2u64.pow(2*N-1)..2u64.pow(2*N)).map(|x| (x.count_ones()==N) as u64).sum();
    println!(&quot;Total unique paths: {}&quot;, 2*n_ends);
}
</code></pre>
<p>Go get another coffee. This took ~15 minutes on my machine. In the end, the mathematical solution is the way to go, but it&#x27;s still fun to explore other solutions.</p></div><br/></div></div></div><footer><div class="wrapper"><div class="footer-wrapper"><div class="footer-col"><ul class="dotless-list"><li>mntn.dev</li><li>Thomas Gorham 2021</li></ul></div><div class="footer-col"><ul class="dotless-list"><li><a href="/colophon">Colophon</a></li></ul></div></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"allPostsData":[{"id":"project-euler-15-addendum","content":"\n*This is an addendum to [this previous post](/blog/project-euler-15).*\n# It's learnin' time\nWhile completing advent of code 2020, I learned about [memoization](https://en.wikipedia.org/wiki/Memoization). I realized that this is a perfect problem to apply the technique to. All we need is a hashmap indexed by our tree coordinates that we'll pass in our recursive function. If there's a cached value for the function inputs, we early return the cached value. In our normal return path we save off the calculated value before actually returning it. It's a simple formula for faster processing.\n\nWithout further ado:\n```rust\nuse std::collections::HashMap;\n\n#[derive(Hash, Eq, PartialEq, Debug)]\nstruct Coordinate {\n    x: u32,\n    y: u32,\n}\n\n// The size of our domain in steps\n// The grid is NxN steps\n// Really, our position grid is N+1xN+1\n// [0,0] describes the start and [N,N] describes the end point\nstatic N:u32 = 20;\n\nfn build_node(x:u32, y:u32, cache:\u0026mut HashMap\u003cCoordinate, u64\u003e) -\u003e u64 {\n    let c = Coordinate{x,y};\n    let mut sum:u64 = 0;\n    if cache.contains_key(\u0026c) {\n        return cache[\u0026c];\n    }\n    // If x==y==N, we're at the end point!\n    if x == N \u0026\u0026 y == N {\n        return 1;\n    }\n    // Recurse for each child node if possible\n    if x \u003c N {\n        sum += build_node(x + 1, y, cache);\n    }\n    if y \u003c N {\n        sum += build_node(x, y + 1, cache);\n    }\n    \n    cache.insert(c, sum);\n    return sum;\n}\n\nfn main() {\n    let mut cache:HashMap\u003cCoordinate, u64\u003e = HashMap::new();\n    let n_ends:u64 = build_node(0, 0, \u0026mut cache);\n    println!(\"Total unique paths: {}\", n_ends);\n}\n```\n\nNow it takes ~5ms to evaluate every path in a 20x20 grid! That's a heck of a lot better than 30min.\n","dateString":"Sat Feb 06 2021","title":"Project Euler Problem #15 - Addendum","date":"2021-02-06 00:00:00 -0500","categories":"code"},{"id":"requests-cache","content":"\n# The Problem\nLately, I've been playing with algorithmic trading using [Backtrader](https://www.backtrader.com/), which is a spectacular tool for experimenting with algorithmic trading strategies. This hobby could be considered a problem in itself, but that's not today's topic. A strategy I've been testing involves maintaining a list of S\u0026P500 stocks, ranking them by some metrics, and making a portfolio out of the top 20% or so. Essentially, a really impersonal buy-and-hold strategy.\n\nUnfortunately, this means I need to collect data on 500 stocks over my backtesting time range (5+ years). I would really prefer to use Backtrader's automatic Yahoo Finance data source `bt.feeds.YahooFinanceData`, but I don't want to send 500+ requests to Yahoo every time I tweak a single variable. On a list of just 16 stocks, it takes ~40 seconds to query 5 years of data and run the strategy. There has to be a better way.\n\n# Enter `requests-cache`!\nBacktrader supports proxies (so we could set up a caching proxy), but under the hood, backtrader's [Yahoo feed](https://github.com/mementum/backtrader/blob/master/backtrader/feeds/yahoo.py) uses the `requests` module! This means we can solve our problem without even touching a proxy service or having to set up local SSL certificates to cache HTTPS.\n\nAll we need to do is run `pip install requests-cache` and add two lines of code to the start of our Backtrader script.\n\n```python\nimport requests_cache\nrequests_cache.install_cache('test_cache', expire_after=3600)\n```\n\nNow, requests-cache will automatically cache any requests made via the python `request` module in a file called `test_cache.sqlite`. Even HTTPS. With this little change, backtesting against 16 stocks over 5 years finishes in 10 seconds: an improvement of 75%!","dateString":"Wed Feb 03 2021","title":"Faster Backtesting with requests-cache","date":"2021-02-03 00:00:00 -0500","categories":"code"},{"id":"project-euler-15","content":"\n*Doing the right things the wrong way.*\n\n# Intro\n[Problem #15](https://projecteuler.net/problem=15) from [Project Euler](https://projecteuler.net/about) is a really interesting problem. Not only is there a clean mathematical solution to the question, but there are a *bunch* of non-optimal (or even downright ugly) but intuitive ways to solve the problem.\n\n# The Easy Way\nThe easiest, and probably fastest, way to solve this problem is to just use math. Consider the rules of the problem:\n1. Each path is composed of *2N* steps that lead from the top left to the bottom right of the domain.\n2. Each step can only be a rightward or downward move.\n3. Because of the start and end positions, each path must have an equal number of down and right moves.\n\nBased on these rules, you can build a valid path by starting with an empty list of *2N* steps, selecting *N* steps to place a rightward move, and filling the remaining steps with downward moves. This is a [Combination Problem](https://en.wikipedia.org/wiki/Combination)! The number of valid paths you can possibly construct is *2N choose N*.\n\n# A Fun Way\n![Tree Diagram](/img/treediagram.png)\n\nMaybe you're itching for a reason to think about binary trees. You can look at every step in a path as a node in a binary tree. The starting position is the root node. The root node has two child nodes, one for a downward move and one for a rightward move. Each of those nodes have their own children in the same pattern. This means that two of the \"grandchild\" nodes actually describe different paths to the same point. In the above picture, downward moves are to the left and rightward to the right.\n\nUsing this tree, we can describe any path on an infinite grid. To constrain the grid (and know when we've reached the end point), we need to add some state to each node: an x and y position: (x,y). To create a new downward node in our domain, y must be less than *N* - the new node's y value will be increased by 1. To create a new rightward node, x must be less than *N* - we'll increase the node's x. If a new node has state *x == N* and *y == N*, we've hit the end point of the grid!\n\nIf we actually build out this tree to full *2N* depth, we'll eat up a ton of memory. Conveniently, we don't actually need to hold all of this state since we're only interested in how many nodes in the tree are at the end point. We can just pretend to build the tree with a recursive function. Here's an implementation in RustðŸ¦€:\n\n```rust\n// The size of our domain in steps\n// The grid is NxN steps\n// Really, our position grid is N+1xN+1\n// [0,0] describes the start and [N,N] describes the end point\nstatic N:u32 = 20;\n\nfn build_node(x:u32, y:u32, n_ends:\u0026mut u64) {\n    // If x==y==N, we're at the end point!\n    if x == N \u0026\u0026 y == N {\n        *n_ends += 1;\n        return;\n    }\n    // Recurse for each child node if possible\n    if x \u003c N {\n        build_node(x + 1, y, n_ends);\n    }\n    if y \u003c N {\n        build_node(x, y + 1, n_ends);\n    }\n}\n\nfn main() {\n    let mut n_ends:u64 = 0;\n    // This describes the root node\n    build_node(0, 0, \u0026mut n_ends);\n    println!(\"Total unique paths: {}\", n_ends);\n}\n```\n\nGo get a coffee or two, because this took ~30min to run on my machine.\n\n*Edit: This can be heavily optimized without abandoning the tree structure! More info in [this more recent post](/blog/project-euler-15-addendum).*\n# An ugly way\nSuppose you were told to solve this problem on an FPGA and you have *no clue* what combination is. Since we know the length of a path is *2N*, we'll start with a *2N*-bit wide counter. Let's say down = 1 and right = 0. We can initialize a down-counter with all 1s and let it run all the way down to 0. Since we know a valid path has #rights=#downs=*N*, we'll look at every counter value and keep track of the number of values which have exactly *N* ones. That number is the number of possible paths! \n\nWe can even slightly optimize this by recognizing that we only have to evalute all of the paths that start with a downward move and multiply the result by two. This follows from our tree representation above. Rust example below:\n\n```rust\n// The size of our domain in steps\nstatic N:u32 = 20;\n\nfn main() {\n    let n_ends:u64 = (2u64.pow(2*N-1)..2u64.pow(2*N)).map(|x| (x.count_ones()==N) as u64).sum();\n    println!(\"Total unique paths: {}\", 2*n_ends);\n}\n```\n\nGo get another coffee. This took ~15 minutes on my machine. In the end, the mathematical solution is the way to go, but it's still fun to explore other solutions.","dateString":"Fri Nov 13 2020","title":"Project Euler Problem #15","date":"2020-11-13 17:00:00 -0500","categories":"code"},{"id":"docker-zfs-deb-1","content":"\n*Building a capable Docker Machine on a Dell R710*\n\n![ZFS Docker and Debian Icons](/img/zfs_docker_debian.png)\n\n# How'd we Get Here...\nA while back, I snagged a Dell R710 from Ebay for $350 delivered. This thing is a virtualization *monster*. 8 cores and 144GB of ECC RAM, perfect for filling with bhyve virtual machines on FreeNAS. This setup worked great for me until I became interested in Docker containers. FreeNAS just doesn't support a docker environment, so let's build something from the ground up and document the process.\n\n# Constraints\n- Must use ZFS (no need for ZFS root)\n- Native docker support\n- Lightweight (no GUI, unnecessary package systems \\*cough cough snaps\\*, etc.)\n\nWith these constraints, we know we absolutely must use Linux and we would really like a distro that has openzfs in its package control. In the past I've used Ubuntu Server and ubuntu 16.04 has zfs available as a package, but I want to avoid snaps like the plague. Because of this, I'm going to use Debian.\n\n# Initial Setup\nFirst things first, we're going to shut down the server and remove every drive but our desired boot drive. FreeNAS uses a flash drive as its root storage, but debian doesn't quite support that. In my case, I'm going to use an old 120GB SSD in an optical drive caddy in place of the server's disk drive. It's easy enough to complete the guided install, and Debian has some pretty good installation literature:\n- [Installation Guide - Long](https://www.debian.org/releases/stable/i386/index.en.html)\n- [Installation Howto - Short](https://www.debian.org/releases/stable/i386/apa.en.html)\n\nI do have a few gotchas during the guided install:\n- Some NICs require closed-source firmware to operate. The NIC in my R710 is one of those, so I had to use the [non-free debian image](https://cdimage.debian.org/cdimage/unofficial/non-free/cd-including-firmware/current/).\n- Guided partitioning failed for my install. I suspect that this is because it was trying to make a gigantic swap partition to match the 144GB of RAM. I decided not to use a swap partition and partition the entire SSD as `/`.\n- I avoided giving root a password. Instead, I have an administrator user with sudo access.\n- I did not install any desktop environments or X server components.\n- Don't forget to select openssh!\n\n# Post-Install\nNow that we have a fully running debian system, let's change a few things. Pop all your drives back in and ssh in.\n\nLet's gear up to use ssh without a password, starting by setting up private key authentication. If you're on linux, you've got it easy: `$ ssh-copy-id $USER@$HOST`. On Windows, I find it easiest to manually copy the contents of `%HOMEPATH%\\.ssh\\id_rsa.pub` to `~/.ssh/authorized_keys` on my server. If you don't have an `~/.ssh/id_rsa.pub` or `%HOMEPATH%\\.ssh\\id_rsa.pub`, you better generate an ssh key with `$ ssh-keygen`.\n\nOnce your public key is copied in, it's a good idea to exit your ssh session and attempt to login with private key auth. If you don't need a password, you're on the right path. Time to disable password authentication. In `/etc/ssh/sshd_config`, find the lines containing the following keys, uncomment them and make sure they're set to `no`.\n\n```\nPasswordAuthentication no\nChallengeResponseAuthentication no\nPermitRootLogin no\nUsePAM no\n```\n\nNow you can reload sshd and bask in paswordless security strong enough to leave exposed publicly. `$ sudo /etc/init.d/sshd reload`\n\n# ZFS Time\nDebian makes this one super easy. Check the [official ZFS Debian Wiki Page](https://wiki.debian.org/ZFS) for more info. Use the following commands to install ZFS on Debian.\n```bash\n$ sudo apt update\n$ sudo apt install linux-headers-`uname -r`\n$ sudo apt install -t buster-backports dkms sol-dkms\n$ sudo apt install -t buster-backports zfs-dkms zfsutils-linux\n```\nIt may take a little while to run the dkms build, and it may throw a few warnings. They do not specifically recommend a reboot on the Debian Wiki, but it's never a bad idea when dealing with kernel modules.\n\nJust for grins, if you happen to be installing on a system that used to run FreeNAS, you can try to import your old pool with `$ sudo zpool import`. You're likely to see `action: The pool can be imported using its name or numeric identifier and the '-f' flag.`. You can force the import by running `$ sudo zpool import -f $POOLNAME`.\n\nIf you're starting fresh, now is the time to make your first zfs pool. I'm in a bit of a hard drive shortage, so for testing's sake I will be doing a stripe pool with two 500GB hard drives. ZFS uses disk IDs or paths to reference disks instead of /dev/sdX paths. You can figure out which disk is which with the following commands:\n```\n$ ls -l /dev/disk/by-id\n$ ls -l /dev/disk/by-path\n$ lsblk -o NAME,SIZE,MODEL,VENDOR\n```\nWith the device IDs in hand, I'll make a zpool with:\n```\n$ sudo zpool create tank ata-ST9500325AS_6VESPM0A ata-ST9500325AS_6VESRNXY\n```\n\n# Docker Install\nThis is essentially a summary of the [Docker Docs for Debian](https://docs.docker.com/engine/install/debian/).\n\n1. Update apt and install required packages:\n```\n$ sudo apt update\n$ sudo apt install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg-agent \\\n    software-properties-common\n```\n2. Get Docker's GPG key:\n```\n$ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -\n```\nYou can verify you have the correct key as follows:\n```\n$ sudo apt-key fingerprint 0EBFCD88\npub   4096R/0EBFCD88 2017-02-22\n      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\nuid                  Docker Release (CE deb) \u003cdocker@docker.com\u003e\nsub   4096R/F273FCD8 2017-02-22\n```\n3. Use the following command to set up Docker stable.\n```\n$ sudo add-apt-repository \\\n   \"deb [arch=amd64] https://download.docker.com/linux/debian \\\n   $(lsb_release -cs) \\\n   stable\"\n```\n4. Finally, install docker!\n```\n$ sudo apt update\n$ sudo apt install docker-ce docker-ce-cli containerd-io\n```\n5. If you want to allow other users to run docker commands, you can set that up [as follows](https://docs.docker.com/engine/install/linux-postinstall/):\n```\n$ sudo groupadd docker\n$ sudo usermod -aG docker $USER\n```\nLog out and back in\n1. You can verify that your docker install is functional by running `hello-world`\n```\n$ docker run --rm hello-world\n```\n\n# Let's Hook up Docker and ZFS\nThis part's for the adventurous. You could certainly just make a bunch of ZFS datasets with filesystem mounts and mount those in your containers for bulk storage, but that's no fun! Docker has a [ZFS storage driver](https://docs.docker.com/storage/storagedriver/zfs-driver/) that will back all container, image, and volume storage with zfs. Let's set it up.\n1. Kill docker:\n```\n$ sudo /etc/init.d/docker stop\n```\n2. Back up /var/lib/docker just in case and then delete its contents:\n```\n$ sudo cp -au /var/lib/docker /var/lib/docker.bk\n$ sudo rm -rf /var/lib/docker/*\n```\n3. Create a ZFS-backed mountpoint at `/var/lib/docker`. The official docker instructions suggest making a zpool and mounting it there, but I'll use a dataset since I already have a zpool configured (name `tank`).\n```\n$ sudo zfs create -o mountpoint=/var/lib/docker tank/docker\n```\n4. Tell Docker to use ZFS for its storage driver. In `/etc/docker/daemon.json`:\n```\n{\n  \"storage-driver\": \"zfs\"\n}\n```\n5. Start docker back up and verify you're using the ZFS storage driver:\n```\n$ sudo /etc/init.d/docker start\n$ docker info\nServer:\n Containers: 0\n  Running: 0\n  Paused: 0\n  Stopped: 0\n Images: 114\n Server Version: 19.03.11\n Storage Driver: zfs\n  Zpool: tank\n  Zpool Health: ONLINE\n  Parent Dataset: tank/docker\n  Space Used By Parent: 17283463680\n  Space Available: 935802788864\n  Parent Quota: no\n  Compression: off\n Logging Driver: json-file\n Cgroup Driver: cgroupfs\n```\n\n# ðŸŽ‰ Done!\nNow we have a server running Debian with Docker using ZFS-backed storage. This would be a great way to put together a NAS setup using samba or NFS with a bunch of self-hosted services. I'll be using Docker to host a home assistant instance with nginx sitting in front as a reverse proxy.","dateString":"Sat Oct 03 2020","title":"Docker \u0026 ZFS On Debian","date":"2020-10-03 9:45:00 -0500","categories":"homelab"}]},"__N_SSG":true},"page":"/blog/[postId]","query":{"postId":"project-euler-15"},"buildId":"w0SKnL3PHckv8cVsElYGO","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-feb8a7604fa7fce626b2.js"></script><script src="/_next/static/chunks/main-b0c7974219aef92009e3.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.e2fe4ae6b85b1c7a6eb1.js" async=""></script><script src="/_next/static/chunks/54b56f31e4a63390429c9c080bc5921c15532dc8.bd079db40d49792afdb6.js" async=""></script><script src="/_next/static/chunks/pages/_app-8e54f29680ba8022333b.js" async=""></script><script src="/_next/static/chunks/9c82dd96d47f7e65c3cc5f64ff6b92c39ae32daa.9fed936b4ac0e3903de0.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5BpostId%5D-f2c0fc5138d8706d07d3.js" async=""></script><script src="/_next/static/w0SKnL3PHckv8cVsElYGO/_buildManifest.js" async=""></script><script src="/_next/static/w0SKnL3PHckv8cVsElYGO/_ssgManifest.js" async=""></script></body></html>