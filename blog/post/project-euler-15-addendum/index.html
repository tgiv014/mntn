<!DOCTYPE html><html lang="en"><head><meta name="generator" content="React Static"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, shrink-to-fit=no"/><link rel="preload" as="script" href="/templates/styles.3592562f.js"/><link rel="preload" as="script" href="/templates/vendors~main.b60da2e7.js"/><link rel="preload" as="script" href="/main.e9e3ebf8.js"/><link rel="preload" as="style" href="/styles.9d2f3657.css"/><link rel="stylesheet" href="/styles.9d2f3657.css"/></head><body><div id="root"><div style="outline:none" tabindex="-1"><nav><div class="wrapper"><div class="header-wrapper"><div class="header-col"><a href="/"><svg class="logo-container" viewBox="0 0 12.4355 5.8209889"><g transform="translate(-1.0582919,-1.0582557)"><path class="logo" d="m 1.9843752,5.953161 3.96875,-3.9688494 2.6458334,2.6458994 1.3229163,-1.32295 2.6458331,2.6459" id="path862"></path></g></svg></a></div><div class="header-col"><a href="/about">About</a><a href="/blog">Blog</a></div></div></div></nav><div class="content"><div class="wrapper"><div style="outline:none" tabindex="-1"><div><div class="backline"><a href="/blog/"><h1>&lt;</h1></a><h1>Project Euler Problem #15 - Addendum</h1></div><br/><em>Sat Feb 06 2021</em><div><p><em>This is an addendum to <a href="/blog/post/project-euler-15">this previous post</a>.</em></p>
<h1>It's learnin' time</h1>
<p>While completing advent of code 2020, I learned about <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a>. I realized that this is a perfect problem to apply the technique to. All we need is a hashmap indexed by our tree coordinates that we'll pass in our recursive function. If there's a cached value for the function inputs, we early return the cached value. In our normal return path we save off the calculated value before actually returning it. It's a simple formula for faster processing.</p>
<p>Without further ado:</p>
<pre><code class="language-rust">use std::collections::HashMap;

#[derive(Hash, Eq, PartialEq, Debug)]
struct Coordinate {
    x: u32,
    y: u32,
}

// The size of our domain in steps
// The grid is NxN steps
// Really, our position grid is N+1xN+1
// [0,0] describes the start and [N,N] describes the end point
static N:u32 = 20;

fn build_node(x:u32, y:u32, cache:&#x26;mut HashMap&#x3C;Coordinate, u64>) -> u64 {
    let c = Coordinate{x,y};
    let mut sum:u64 = 0;
    if cache.contains_key(&#x26;c) {
        return cache[&#x26;c];
    }
    // If x==y==N, we're at the end point!
    if x == N &#x26;&#x26; y == N {
        return 1;
    }
    // Recurse for each child node if possible
    if x &#x3C; N {
        sum += build_node(x + 1, y, cache);
    }
    if y &#x3C; N {
        sum += build_node(x, y + 1, cache);
    }
    
    cache.insert(c, sum);
    return sum;
}

fn main() {
    let mut cache:HashMap&#x3C;Coordinate, u64> = HashMap::new();
    let n_ends:u64 = build_node(0, 0, &#x26;mut cache);
    println!("Total unique paths: {}", n_ends);
}
</code></pre>
<p>Now it takes ~5ms to evaluate every path in a 20x20 grid! That's a heck of a lot better than 30min.</p>
</div><br/></div></div></div></div><footer><div class="wrapper"><div class="footer-wrapper"><div class="footer-col"><ul class="dotless-list"><li>mntn.dev</li><li>Â© Thomas Gorham 2021</li></ul></div><div class="footer-col"><ul class="dotless-list"><li><a href="/colophon">Colophon</a></li></ul></div></div></div></footer></div></div><script type="text/javascript">window.__routeInfo = JSON.parse("{\"template\":\"__react_static_root__/src/containers/Post\",\"sharedHashesByProp\":{},\"data\":{\"html\":{\"__html\":\"<p><em>This is an addendum to <a href=\\\"/blog/post/project-euler-15\\\">this previous post</a>.</em></p>\\n<h1>It's learnin' time</h1>\\n<p>While completing advent of code 2020, I learned about <a href=\\\"https://en.wikipedia.org/wiki/Memoization\\\">memoization</a>. I realized that this is a perfect problem to apply the technique to. All we need is a hashmap indexed by our tree coordinates that we'll pass in our recursive function. If there's a cached value for the function inputs, we early return the cached value. In our normal return path we save off the calculated value before actually returning it. It's a simple formula for faster processing.</p>\\n<p>Without further ado:</p>\\n<pre><code class=\\\"language-rust\\\">use std::collections::HashMap;\\n\\n#[derive(Hash, Eq, PartialEq, Debug)]\\nstruct Coordinate {\\n    x: u32,\\n    y: u32,\\n}\\n\\n// The size of our domain in steps\\n// The grid is NxN steps\\n// Really, our position grid is N+1xN+1\\n// [0,0] describes the start and [N,N] describes the end point\\nstatic N:u32 = 20;\\n\\nfn build_node(x:u32, y:u32, cache:&#x26;mut HashMap&#x3C;Coordinate, u64>) -> u64 {\\n    let c = Coordinate{x,y};\\n    let mut sum:u64 = 0;\\n    if cache.contains_key(&#x26;c) {\\n        return cache[&#x26;c];\\n    }\\n    // If x==y==N, we're at the end point!\\n    if x == N &#x26;&#x26; y == N {\\n        return 1;\\n    }\\n    // Recurse for each child node if possible\\n    if x &#x3C; N {\\n        sum += build_node(x + 1, y, cache);\\n    }\\n    if y &#x3C; N {\\n        sum += build_node(x, y + 1, cache);\\n    }\\n    \\n    cache.insert(c, sum);\\n    return sum;\\n}\\n\\nfn main() {\\n    let mut cache:HashMap&#x3C;Coordinate, u64> = HashMap::new();\\n    let n_ends:u64 = build_node(0, 0, &#x26;mut cache);\\n    println!(\\\"Total unique paths: {}\\\", n_ends);\\n}\\n</code></pre>\\n<p>Now it takes ~5ms to evaluate every path in a 20x20 grid! That's a heck of a lot better than 30min.</p>\\n\"},\"post\":{\"fname\":\"project-euler-15-addendum.md\",\"data\":{\"title\":\"Project Euler Problem #15 - Addendum\",\"date\":\"2021-02-06 00:00:00 -0500\",\"categories\":\"code\"},\"md\":\"<p><em>This is an addendum to <a href=\\\"/blog/post/project-euler-15\\\">this previous post</a>.</em></p>\\n<h1>It's learnin' time</h1>\\n<p>While completing advent of code 2020, I learned about <a href=\\\"https://en.wikipedia.org/wiki/Memoization\\\">memoization</a>. I realized that this is a perfect problem to apply the technique to. All we need is a hashmap indexed by our tree coordinates that we'll pass in our recursive function. If there's a cached value for the function inputs, we early return the cached value. In our normal return path we save off the calculated value before actually returning it. It's a simple formula for faster processing.</p>\\n<p>Without further ado:</p>\\n<pre><code class=\\\"language-rust\\\">use std::collections::HashMap;\\n\\n#[derive(Hash, Eq, PartialEq, Debug)]\\nstruct Coordinate {\\n    x: u32,\\n    y: u32,\\n}\\n\\n// The size of our domain in steps\\n// The grid is NxN steps\\n// Really, our position grid is N+1xN+1\\n// [0,0] describes the start and [N,N] describes the end point\\nstatic N:u32 = 20;\\n\\nfn build_node(x:u32, y:u32, cache:&#x26;mut HashMap&#x3C;Coordinate, u64>) -> u64 {\\n    let c = Coordinate{x,y};\\n    let mut sum:u64 = 0;\\n    if cache.contains_key(&#x26;c) {\\n        return cache[&#x26;c];\\n    }\\n    // If x==y==N, we're at the end point!\\n    if x == N &#x26;&#x26; y == N {\\n        return 1;\\n    }\\n    // Recurse for each child node if possible\\n    if x &#x3C; N {\\n        sum += build_node(x + 1, y, cache);\\n    }\\n    if y &#x3C; N {\\n        sum += build_node(x, y + 1, cache);\\n    }\\n    \\n    cache.insert(c, sum);\\n    return sum;\\n}\\n\\nfn main() {\\n    let mut cache:HashMap&#x3C;Coordinate, u64> = HashMap::new();\\n    let n_ends:u64 = build_node(0, 0, &#x26;mut cache);\\n    println!(\\\"Total unique paths: {}\\\", n_ends);\\n}\\n</code></pre>\\n<p>Now it takes ~5ms to evaluate every path in a 20x20 grid! That's a heck of a lot better than 30min.</p>\\n\",\"stripped\":\"project-euler-15-addendum\"}},\"path\":\"blog/post/project-euler-15-addendum\",\"sharedData\":{},\"siteData\":{}}");</script><script defer="" type="text/javascript" src="/templates/styles.3592562f.js"></script><script defer="" type="text/javascript" src="/templates/vendors~main.b60da2e7.js"></script><script defer="" type="text/javascript" src="/main.e9e3ebf8.js"></script></body></html>