{"template":"__react_static_root__/src/containers/Post","sharedHashesByProp":{},"data":{"html":{"__html":"<p><em>This is an addendum to <a href=\"/blog/post/project-euler-15\">this previous post</a>.</em></p>\n<h1>It's learnin' time</h1>\n<p>While completing advent of code 2020, I learned about <a href=\"https://en.wikipedia.org/wiki/Memoization\">memoization</a>. I realized that this is a perfect problem to apply the technique to. All we need is a hashmap indexed by our tree coordinates that we'll pass in our recursive function. If there's a cached value for the function inputs, we early return the cached value. In our normal return path we save off the calculated value before actually returning it. It's a simple formula for faster processing.</p>\n<p>Without further ado:</p>\n<pre><code class=\"language-rust\">use std::collections::HashMap;\n\n#[derive(Hash, Eq, PartialEq, Debug)]\nstruct Coordinate {\n    x: u32,\n    y: u32,\n}\n\n// The size of our domain in steps\n// The grid is NxN steps\n// Really, our position grid is N+1xN+1\n// [0,0] describes the start and [N,N] describes the end point\nstatic N:u32 = 20;\n\nfn build_node(x:u32, y:u32, cache:&#x26;mut HashMap&#x3C;Coordinate, u64>) -> u64 {\n    let c = Coordinate{x,y};\n    let mut sum:u64 = 0;\n    if cache.contains_key(&#x26;c) {\n        return cache[&#x26;c];\n    }\n    // If x==y==N, we're at the end point!\n    if x == N &#x26;&#x26; y == N {\n        return 1;\n    }\n    // Recurse for each child node if possible\n    if x &#x3C; N {\n        sum += build_node(x + 1, y, cache);\n    }\n    if y &#x3C; N {\n        sum += build_node(x, y + 1, cache);\n    }\n    \n    cache.insert(c, sum);\n    return sum;\n}\n\nfn main() {\n    let mut cache:HashMap&#x3C;Coordinate, u64> = HashMap::new();\n    let n_ends:u64 = build_node(0, 0, &#x26;mut cache);\n    println!(\"Total unique paths: {}\", n_ends);\n}\n</code></pre>\n<p>Now it takes ~5ms to evaluate every path in a 20x20 grid! That's a heck of a lot better than 30min.</p>\n"},"post":{"fname":"project-euler-15-addendum.md","data":{"title":"Project Euler Problem #15 - Addendum","date":"2021-02-06 00:00:00 -0500","categories":"code"},"md":"<p><em>This is an addendum to <a href=\"/blog/post/project-euler-15\">this previous post</a>.</em></p>\n<h1>It's learnin' time</h1>\n<p>While completing advent of code 2020, I learned about <a href=\"https://en.wikipedia.org/wiki/Memoization\">memoization</a>. I realized that this is a perfect problem to apply the technique to. All we need is a hashmap indexed by our tree coordinates that we'll pass in our recursive function. If there's a cached value for the function inputs, we early return the cached value. In our normal return path we save off the calculated value before actually returning it. It's a simple formula for faster processing.</p>\n<p>Without further ado:</p>\n<pre><code class=\"language-rust\">use std::collections::HashMap;\n\n#[derive(Hash, Eq, PartialEq, Debug)]\nstruct Coordinate {\n    x: u32,\n    y: u32,\n}\n\n// The size of our domain in steps\n// The grid is NxN steps\n// Really, our position grid is N+1xN+1\n// [0,0] describes the start and [N,N] describes the end point\nstatic N:u32 = 20;\n\nfn build_node(x:u32, y:u32, cache:&#x26;mut HashMap&#x3C;Coordinate, u64>) -> u64 {\n    let c = Coordinate{x,y};\n    let mut sum:u64 = 0;\n    if cache.contains_key(&#x26;c) {\n        return cache[&#x26;c];\n    }\n    // If x==y==N, we're at the end point!\n    if x == N &#x26;&#x26; y == N {\n        return 1;\n    }\n    // Recurse for each child node if possible\n    if x &#x3C; N {\n        sum += build_node(x + 1, y, cache);\n    }\n    if y &#x3C; N {\n        sum += build_node(x, y + 1, cache);\n    }\n    \n    cache.insert(c, sum);\n    return sum;\n}\n\nfn main() {\n    let mut cache:HashMap&#x3C;Coordinate, u64> = HashMap::new();\n    let n_ends:u64 = build_node(0, 0, &#x26;mut cache);\n    println!(\"Total unique paths: {}\", n_ends);\n}\n</code></pre>\n<p>Now it takes ~5ms to evaluate every path in a 20x20 grid! That's a heck of a lot better than 30min.</p>\n","stripped":"project-euler-15-addendum","date":"2021-02-06T05:00:00.000Z","dateString":"Sat Feb 06 2021"}},"path":"blog/post/project-euler-15-addendum"}
