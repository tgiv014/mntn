<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>mntn.dev - Project Euler Problem #15</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/5e367c032bdf8114c40f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5e367c032bdf8114c40f.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-b0c7974219aef92009e3.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.e2fe4ae6b85b1c7a6eb1.js" as="script"/><link rel="preload" href="/_next/static/chunks/54b56f31e4a63390429c9c080bc5921c15532dc8.bd079db40d49792afdb6.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-8e54f29680ba8022333b.js" as="script"/><link rel="preload" href="/_next/static/chunks/9c82dd96d47f7e65c3cc5f64ff6b92c39ae32daa.1fc51c4ad0cb6bb4bd9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5BpostId%5D-00cea468919eec8492f5.js" as="script"/></head><body><div id="__next"><div><nav><div class="wrapper"><div class="header-wrapper"><div class="header-col"><a href="/"><svg class="logo-container" viewBox="0 0 12.4355 5.8209889"><g transform="translate(-1.0582919,-1.0582557)"><path class="logo" d="m 1.9843752,5.953161 3.96875,-3.9688494 2.6458334,2.6458994 1.3229163,-1.32295 2.6458331,2.6459" id="path862"></path></g></svg></a></div><div class="header-col"><a href="/about">About</a><a href="/blog">Blog</a></div></div></div></nav><div class="content"><div class="wrapper"><div><div class="backline"><a href="/blog"><h1>&lt;</h1></a><h1>Project Euler Problem #15</h1></div><br/><em>Fri Nov 13 2020</em><div><p><em>Doing the right things the wrong way.</em></p>
<h1>Intro</h1>
<p><a href="https://projecteuler.net/problem=15">Problem #15</a> from <a href="https://projecteuler.net/about">Project Euler</a> is a really interesting problem. Not only is there a clean mathematical solution to the question, but there are a <em>bunch</em> of non-optimal (or even downright ugly) but intuitive ways to solve the problem.</p>
<h1>The Easy Way</h1>
<p>The easiest, and probably fastest, way to solve this problem is to just use math. Consider the rules of the problem:</p>
<ol>
<li>Each path is composed of <em>2N</em> steps that lead from the top left to the bottom right of the domain.</li>
<li>Each step can only be a rightward or downward move.</li>
<li>Because of the start and end positions, each path must have an equal number of down and right moves.</li>
</ol>
<p>Based on these rules, you can build a valid path by starting with an empty list of <em>2N</em> steps, selecting <em>N</em> steps to place a rightward move, and filling the remaining steps with downward moves. This is a <a href="https://en.wikipedia.org/wiki/Combination">Combination Problem</a>! The number of valid paths you can possibly construct is <em>2N choose N</em>.</p>
<h1>A Fun Way</h1>
<center>
<img src="/img/treediagram.png"/>
</center>
Maybe you're itching for a reason to think about binary trees. You can look at every step in a path as a node in a binary tree. The starting position is the root node. The root node has two child nodes, one for a downward move and one for a rightward move. Each of those nodes have their own children in the same pattern. This means that two of the "grandchild" nodes actually describe different paths to the same point. In the above picture, downward moves are to the left and rightward to the right.
<p>Using this tree, we can describe any path on an infinite grid. To constrain the grid (and know when we've reached the end point), we need to add some state to each node: an x and y position: (x,y). To create a new downward node in our domain, y must be less than <em>N</em> - the new node's y value will be increased by 1. To create a new rightward node, x must be less than <em>N</em> - we'll increase the node's x. If a new node has state <em>x == N</em> and <em>y == N</em>, we've hit the end point of the grid!</p>
<p>If we actually build out this tree to full <em>2N</em> depth, we'll eat up a ton of memory. Conveniently, we don't actually need to hold all of this state since we're only interested in how many nodes in the tree are at the end point. We can just pretend to build the tree with a recursive function. Here's an implementation in RustðŸ¦€:</p>
<pre><code class="language-rust">// The size of our domain in steps
// The grid is NxN steps
// Really, our position grid is N+1xN+1
// [0,0] describes the start and [N,N] describes the end point
static N:u32 = 20;

fn build_node(x:u32, y:u32, n_ends:&#x26;mut u64) {
    // If x==y==N, we're at the end point!
    if x == N &#x26;&#x26; y == N {
        *n_ends += 1;
        return;
    }
    // Recurse for each child node if possible
    if x &#x3C; N {
        build_node(x + 1, y, n_ends);
    }
    if y &#x3C; N {
        build_node(x, y + 1, n_ends);
    }
}

fn main() {
    let mut n_ends:u64 = 0;
    // This describes the root node
    build_node(0, 0, &#x26;mut n_ends);
    println!("Total unique paths: {}", n_ends);
}
</code></pre>
<p>Go get a coffee or two, because this took ~30min to run on my machine.</p>
<p><em>Edit: This can be heavily optimized without abandoning the tree structure! More info in <a href="/blog/project-euler-15-addendum">this more recent post</a>.</em></p>
<h1>An ugly way</h1>
<p>Suppose you were told to solve this problem on an FPGA and you have <em>no clue</em> what combination is. Since we know the length of a path is <em>2N</em>, we'll start with a <em>2N</em>-bit wide counter. Let's say down = 1 and right = 0. We can initialize a down-counter with all 1s and let it run all the way down to 0. Since we know a valid path has #rights=#downs=<em>N</em>, we'll look at every counter value and keep track of the number of values which have exactly <em>N</em> ones. That number is the number of possible paths!</p>
<p>We can even slightly optimize this by recognizing that we only have to evalute all of the paths that start with a downward move and multiply the result by two. This follows from our tree representation above. Rust example below:</p>
<pre><code class="language-rust">// The size of our domain in steps
static N:u32 = 20;

fn main() {
    let n_ends:u64 = (2u64.pow(2*N-1)..2u64.pow(2*N)).map(|x| (x.count_ones()==N) as u64).sum();
    println!("Total unique paths: {}", 2*n_ends);
}
</code></pre>
<p>Go get another coffee. This took ~15 minutes on my machine. In the end, the mathematical solution is the way to go, but it's still fun to explore other solutions.</p>
</div><br/></div></div></div><footer><div class="wrapper"><div class="footer-wrapper"><div class="footer-col"><ul class="dotless-list"><li>mntn.dev</li><li>Thomas Gorham 2021</li></ul></div><div class="footer-col"><ul class="dotless-list"><li><a href="/colophon">Colophon</a></li></ul></div></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"allPostsData":[{"id":"project-euler-15-addendum","html":{"__html":"\u003cp\u003e\u003cem\u003eThis is an addendum to \u003ca href=\"/blog/project-euler-15\"\u003ethis previous post\u003c/a\u003e.\u003c/em\u003e\u003c/p\u003e\n\u003ch1\u003eIt's learnin' time\u003c/h1\u003e\n\u003cp\u003eWhile completing advent of code 2020, I learned about \u003ca href=\"https://en.wikipedia.org/wiki/Memoization\"\u003ememoization\u003c/a\u003e. I realized that this is a perfect problem to apply the technique to. All we need is a hashmap indexed by our tree coordinates that we'll pass in our recursive function. If there's a cached value for the function inputs, we early return the cached value. In our normal return path we save off the calculated value before actually returning it. It's a simple formula for faster processing.\u003c/p\u003e\n\u003cp\u003eWithout further ado:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-rust\"\u003euse std::collections::HashMap;\n\n#[derive(Hash, Eq, PartialEq, Debug)]\nstruct Coordinate {\n    x: u32,\n    y: u32,\n}\n\n// The size of our domain in steps\n// The grid is NxN steps\n// Really, our position grid is N+1xN+1\n// [0,0] describes the start and [N,N] describes the end point\nstatic N:u32 = 20;\n\nfn build_node(x:u32, y:u32, cache:\u0026#x26;mut HashMap\u0026#x3C;Coordinate, u64\u003e) -\u003e u64 {\n    let c = Coordinate{x,y};\n    let mut sum:u64 = 0;\n    if cache.contains_key(\u0026#x26;c) {\n        return cache[\u0026#x26;c];\n    }\n    // If x==y==N, we're at the end point!\n    if x == N \u0026#x26;\u0026#x26; y == N {\n        return 1;\n    }\n    // Recurse for each child node if possible\n    if x \u0026#x3C; N {\n        sum += build_node(x + 1, y, cache);\n    }\n    if y \u0026#x3C; N {\n        sum += build_node(x, y + 1, cache);\n    }\n    \n    cache.insert(c, sum);\n    return sum;\n}\n\nfn main() {\n    let mut cache:HashMap\u0026#x3C;Coordinate, u64\u003e = HashMap::new();\n    let n_ends:u64 = build_node(0, 0, \u0026#x26;mut cache);\n    println!(\"Total unique paths: {}\", n_ends);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow it takes ~5ms to evaluate every path in a 20x20 grid! That's a heck of a lot better than 30min.\u003c/p\u003e\n"},"dateString":"Sat Feb 06 2021","title":"Project Euler Problem #15 - Addendum","date":"2021-02-06 00:00:00 -0500","categories":"code"},{"id":"requests-cache","html":{"__html":"\u003ch1\u003eThe Problem\u003c/h1\u003e\n\u003cp\u003eLately, I've been playing with algorithmic trading using \u003ca href=\"https://www.backtrader.com/\"\u003eBacktrader\u003c/a\u003e, which is a spectacular tool for experimenting with algorithmic trading strategies. This hobby could be considered a problem in itself, but that's not today's topic. A strategy I've been testing involves maintaining a list of S\u0026#x26;P500 stocks, ranking them by some metrics, and making a portfolio out of the top 20% or so. Essentially, a really impersonal buy-and-hold strategy.\u003c/p\u003e\n\u003cp\u003eUnfortunately, this means I need to collect data on 500 stocks over my backtesting time range (5+ years). I would really prefer to use Backtrader's automatic Yahoo Finance data source \u003ccode\u003ebt.feeds.YahooFinanceData\u003c/code\u003e, but I don't want to send 500+ requests to Yahoo every time I tweak a single variable. On a list of just 16 stocks, it takes ~40 seconds to query 5 years of data and run the strategy. There has to be a better way.\u003c/p\u003e\n\u003ch1\u003eEnter \u003ccode\u003erequests-cache\u003c/code\u003e!\u003c/h1\u003e\n\u003cp\u003eBacktrader supports proxies (so we could set up a caching proxy), but under the hood, backtrader's \u003ca href=\"https://github.com/mementum/backtrader/blob/master/backtrader/feeds/yahoo.py\"\u003eYahoo feed\u003c/a\u003e uses the \u003ccode\u003erequests\u003c/code\u003e module! This means we can solve our problem without even touching a proxy service or having to set up local SSL certificates to cache HTTPS.\u003c/p\u003e\n\u003cp\u003eAll we need to do is run \u003ccode\u003epip install requests-cache\u003c/code\u003e and add two lines of code to the start of our Backtrader script.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport requests_cache\nrequests_cache.install_cache('test_cache', expire_after=3600)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, requests-cache will automatically cache any requests made via the python \u003ccode\u003erequest\u003c/code\u003e module in a file called \u003ccode\u003etest_cache.sqlite\u003c/code\u003e. Even HTTPS. With this little change, backtesting against 16 stocks over 5 years finishes in 10 seconds: an improvement of 75%!\u003c/p\u003e\n"},"dateString":"Wed Feb 03 2021","title":"Faster Backtesting with requests-cache","date":"2021-02-03 00:00:00 -0500","categories":"code"},{"id":"project-euler-15","html":{"__html":"\u003cp\u003e\u003cem\u003eDoing the right things the wrong way.\u003c/em\u003e\u003c/p\u003e\n\u003ch1\u003eIntro\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://projecteuler.net/problem=15\"\u003eProblem #15\u003c/a\u003e from \u003ca href=\"https://projecteuler.net/about\"\u003eProject Euler\u003c/a\u003e is a really interesting problem. Not only is there a clean mathematical solution to the question, but there are a \u003cem\u003ebunch\u003c/em\u003e of non-optimal (or even downright ugly) but intuitive ways to solve the problem.\u003c/p\u003e\n\u003ch1\u003eThe Easy Way\u003c/h1\u003e\n\u003cp\u003eThe easiest, and probably fastest, way to solve this problem is to just use math. Consider the rules of the problem:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eEach path is composed of \u003cem\u003e2N\u003c/em\u003e steps that lead from the top left to the bottom right of the domain.\u003c/li\u003e\n\u003cli\u003eEach step can only be a rightward or downward move.\u003c/li\u003e\n\u003cli\u003eBecause of the start and end positions, each path must have an equal number of down and right moves.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eBased on these rules, you can build a valid path by starting with an empty list of \u003cem\u003e2N\u003c/em\u003e steps, selecting \u003cem\u003eN\u003c/em\u003e steps to place a rightward move, and filling the remaining steps with downward moves. This is a \u003ca href=\"https://en.wikipedia.org/wiki/Combination\"\u003eCombination Problem\u003c/a\u003e! The number of valid paths you can possibly construct is \u003cem\u003e2N choose N\u003c/em\u003e.\u003c/p\u003e\n\u003ch1\u003eA Fun Way\u003c/h1\u003e\n\u003ccenter\u003e\n\u003cimg src=\"/img/treediagram.png\"/\u003e\n\u003c/center\u003e\nMaybe you're itching for a reason to think about binary trees. You can look at every step in a path as a node in a binary tree. The starting position is the root node. The root node has two child nodes, one for a downward move and one for a rightward move. Each of those nodes have their own children in the same pattern. This means that two of the \"grandchild\" nodes actually describe different paths to the same point. In the above picture, downward moves are to the left and rightward to the right.\n\u003cp\u003eUsing this tree, we can describe any path on an infinite grid. To constrain the grid (and know when we've reached the end point), we need to add some state to each node: an x and y position: (x,y). To create a new downward node in our domain, y must be less than \u003cem\u003eN\u003c/em\u003e - the new node's y value will be increased by 1. To create a new rightward node, x must be less than \u003cem\u003eN\u003c/em\u003e - we'll increase the node's x. If a new node has state \u003cem\u003ex == N\u003c/em\u003e and \u003cem\u003ey == N\u003c/em\u003e, we've hit the end point of the grid!\u003c/p\u003e\n\u003cp\u003eIf we actually build out this tree to full \u003cem\u003e2N\u003c/em\u003e depth, we'll eat up a ton of memory. Conveniently, we don't actually need to hold all of this state since we're only interested in how many nodes in the tree are at the end point. We can just pretend to build the tree with a recursive function. Here's an implementation in RustðŸ¦€:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-rust\"\u003e// The size of our domain in steps\n// The grid is NxN steps\n// Really, our position grid is N+1xN+1\n// [0,0] describes the start and [N,N] describes the end point\nstatic N:u32 = 20;\n\nfn build_node(x:u32, y:u32, n_ends:\u0026#x26;mut u64) {\n    // If x==y==N, we're at the end point!\n    if x == N \u0026#x26;\u0026#x26; y == N {\n        *n_ends += 1;\n        return;\n    }\n    // Recurse for each child node if possible\n    if x \u0026#x3C; N {\n        build_node(x + 1, y, n_ends);\n    }\n    if y \u0026#x3C; N {\n        build_node(x, y + 1, n_ends);\n    }\n}\n\nfn main() {\n    let mut n_ends:u64 = 0;\n    // This describes the root node\n    build_node(0, 0, \u0026#x26;mut n_ends);\n    println!(\"Total unique paths: {}\", n_ends);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGo get a coffee or two, because this took ~30min to run on my machine.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eEdit: This can be heavily optimized without abandoning the tree structure! More info in \u003ca href=\"/blog/project-euler-15-addendum\"\u003ethis more recent post\u003c/a\u003e.\u003c/em\u003e\u003c/p\u003e\n\u003ch1\u003eAn ugly way\u003c/h1\u003e\n\u003cp\u003eSuppose you were told to solve this problem on an FPGA and you have \u003cem\u003eno clue\u003c/em\u003e what combination is. Since we know the length of a path is \u003cem\u003e2N\u003c/em\u003e, we'll start with a \u003cem\u003e2N\u003c/em\u003e-bit wide counter. Let's say down = 1 and right = 0. We can initialize a down-counter with all 1s and let it run all the way down to 0. Since we know a valid path has #rights=#downs=\u003cem\u003eN\u003c/em\u003e, we'll look at every counter value and keep track of the number of values which have exactly \u003cem\u003eN\u003c/em\u003e ones. That number is the number of possible paths!\u003c/p\u003e\n\u003cp\u003eWe can even slightly optimize this by recognizing that we only have to evalute all of the paths that start with a downward move and multiply the result by two. This follows from our tree representation above. Rust example below:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-rust\"\u003e// The size of our domain in steps\nstatic N:u32 = 20;\n\nfn main() {\n    let n_ends:u64 = (2u64.pow(2*N-1)..2u64.pow(2*N)).map(|x| (x.count_ones()==N) as u64).sum();\n    println!(\"Total unique paths: {}\", 2*n_ends);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGo get another coffee. This took ~15 minutes on my machine. In the end, the mathematical solution is the way to go, but it's still fun to explore other solutions.\u003c/p\u003e\n"},"dateString":"Fri Nov 13 2020","title":"Project Euler Problem #15","date":"2020-11-13 17:00:00 -0500","categories":"code"},{"id":"docker-zfs-deb-1","html":{"__html":"\u003cp\u003e\u003cem\u003eBuilding a capable Docker Machine on a Dell R710\u003c/em\u003e\u003c/p\u003e\n\u003ccenter\u003e\n\u003cimg src=\"/img/zfs_docker_debian.png\"/\u003e\n\u003c/center\u003e\n\u003ch1\u003eHow'd we Get Here...\u003c/h1\u003e\n\u003cp\u003eA while back, I snagged a Dell R710 from Ebay for $350 delivered. This thing is a virtualization \u003cem\u003emonster\u003c/em\u003e. 8 cores and 144GB of ECC RAM, perfect for filling with bhyve virtual machines on FreeNAS. This setup worked great for me until I became interested in Docker containers. FreeNAS just doesn't support a docker environment, so let's build something from the ground up and document the process.\u003c/p\u003e\n\u003ch1\u003eConstraints\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eMust use ZFS (no need for ZFS root)\u003c/li\u003e\n\u003cli\u003eNative docker support\u003c/li\u003e\n\u003cli\u003eLightweight (no GUI, unnecessary package systems *cough cough snaps*, etc.)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWith these constraints, we know we absolutely must use Linux and we would really like a distro that has openzfs in its package control. In the past I've used Ubuntu Server and ubuntu 16.04 has zfs available as a package, but I want to avoid snaps like the plague. Because of this, I'm going to use Debian.\u003c/p\u003e\n\u003ch1\u003eInitial Setup\u003c/h1\u003e\n\u003cp\u003eFirst things first, we're going to shut down the server and remove every drive but our desired boot drive. FreeNAS uses a flash drive as its root storage, but debian doesn't quite support that. In my case, I'm going to use an old 120GB SSD in an optical drive caddy in place of the server's disk drive. It's easy enough to complete the guided install, and Debian has some pretty good installation literature:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.debian.org/releases/stable/i386/index.en.html\"\u003eInstallation Guide - Long\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.debian.org/releases/stable/i386/apa.en.html\"\u003eInstallation Howto - Short\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI do have a few gotchas during the guided install:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSome NICs require closed-source firmware to operate. The NIC in my R710 is one of those, so I had to use the \u003ca href=\"https://cdimage.debian.org/cdimage/unofficial/non-free/cd-including-firmware/current/\"\u003enon-free debian image\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eGuided partitioning failed for my install. I suspect that this is because it was trying to make a gigantic swap partition to match the 144GB of RAM. I decided not to use a swap partition and partition the entire SSD as \u003ccode\u003e/\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eI avoided giving root a password. Instead, I have an administrator user with sudo access.\u003c/li\u003e\n\u003cli\u003eI did not install any desktop environments or X server components.\u003c/li\u003e\n\u003cli\u003eDon't forget to select openssh!\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003ePost-Install\u003c/h1\u003e\n\u003cp\u003eNow that we have a fully running debian system, let's change a few things. Pop all your drives back in and ssh in.\u003c/p\u003e\n\u003cp\u003eLet's gear up to use ssh without a password, starting by setting up private key authentication. If you're on linux, you've got it easy: \u003ccode\u003e$ ssh-copy-id $USER@$HOST\u003c/code\u003e. On Windows, I find it easiest to manually copy the contents of \u003ccode\u003e%HOMEPATH%\\.ssh\\id_rsa.pub\u003c/code\u003e to \u003ccode\u003e~/.ssh/authorized_keys\u003c/code\u003e on my server. If you don't have an \u003ccode\u003e~/.ssh/id_rsa.pub\u003c/code\u003e or \u003ccode\u003e%HOMEPATH%\\.ssh\\id_rsa.pub\u003c/code\u003e, you better generate an ssh key with \u003ccode\u003e$ ssh-keygen\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOnce your public key is copied in, it's a good idea to exit your ssh session and attempt to login with private key auth. If you don't need a password, you're on the right path. Time to disable password authentication. In \u003ccode\u003e/etc/ssh/sshd_config\u003c/code\u003e, find the lines containing the following keys, uncomment them and make sure they're set to \u003ccode\u003eno\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePasswordAuthentication no\nChallengeResponseAuthentication no\nPermitRootLogin no\nUsePAM no\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow you can reload sshd and bask in paswordless security strong enough to leave exposed publicly. \u003ccode\u003e$ sudo /etc/init.d/sshd reload\u003c/code\u003e\u003c/p\u003e\n\u003ch1\u003eZFS Time\u003c/h1\u003e\n\u003cp\u003eDebian makes this one super easy. Check the \u003ca href=\"https://wiki.debian.org/ZFS\"\u003eofficial ZFS Debian Wiki Page\u003c/a\u003e for more info. Use the following commands to install ZFS on Debian.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ sudo apt update\n$ sudo apt install linux-headers-`uname -r`\n$ sudo apt install -t buster-backports dkms sol-dkms\n$ sudo apt install -t buster-backports zfs-dkms zfsutils-linux\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt may take a little while to run the dkms build, and it may throw a few warnings. They do not specifically recommend a reboot on the Debian Wiki, but it's never a bad idea when dealing with kernel modules.\u003c/p\u003e\n\u003cp\u003eJust for grins, if you happen to be installing on a system that used to run FreeNAS, you can try to import your old pool with \u003ccode\u003e$ sudo zpool import\u003c/code\u003e. You're likely to see \u003ccode\u003eaction: The pool can be imported using its name or numeric identifier and the '-f' flag.\u003c/code\u003e. You can force the import by running \u003ccode\u003e$ sudo zpool import -f $POOLNAME\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf you're starting fresh, now is the time to make your first zfs pool. I'm in a bit of a hard drive shortage, so for testing's sake I will be doing a stripe pool with two 500GB hard drives. ZFS uses disk IDs or paths to reference disks instead of /dev/sdX paths. You can figure out which disk is which with the following commands:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ls -l /dev/disk/by-id\n$ ls -l /dev/disk/by-path\n$ lsblk -o NAME,SIZE,MODEL,VENDOR\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith the device IDs in hand, I'll make a zpool with:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo zpool create tank ata-ST9500325AS_6VESPM0A ata-ST9500325AS_6VESRNXY\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eDocker Install\u003c/h1\u003e\n\u003cp\u003eThis is essentially a summary of the \u003ca href=\"https://docs.docker.com/engine/install/debian/\"\u003eDocker Docs for Debian\u003c/a\u003e.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eUpdate apt and install required packages:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt update\n$ sudo apt install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg-agent \\\n    software-properties-common\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eGet Docker's GPG key:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e$ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can verify you have the correct key as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-key fingerprint 0EBFCD88\npub   4096R/0EBFCD88 2017-02-22\n      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\nuid                  Docker Release (CE deb) \u0026#x3C;docker@docker.com\u003e\nsub   4096R/F273FCD8 2017-02-22\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eUse the following command to set up Docker stable.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo add-apt-repository \\\n   \"deb [arch=amd64] https://download.docker.com/linux/debian \\\n   $(lsb_release -cs) \\\n   stable\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003eFinally, install docker!\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt update\n$ sudo apt install docker-ce docker-ce-cli containerd-io\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003eIf you want to allow other users to run docker commands, you can set that up \u003ca href=\"https://docs.docker.com/engine/install/linux-postinstall/\"\u003eas follows\u003c/a\u003e:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo groupadd docker\n$ sudo usermod -aG docker $USER\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLog out and back in\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eYou can verify that your docker install is functional by running \u003ccode\u003ehello-world\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e$ docker run --rm hello-world\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eLet's Hook up Docker and ZFS\u003c/h1\u003e\n\u003cp\u003eThis part's for the adventurous. You could certainly just make a bunch of ZFS datasets with filesystem mounts and mount those in your containers for bulk storage, but that's no fun! Docker has a \u003ca href=\"https://docs.docker.com/storage/storagedriver/zfs-driver/\"\u003eZFS storage driver\u003c/a\u003e that will back all container, image, and volume storage with zfs. Let's set it up.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eKill docker:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo /etc/init.d/docker stop\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eBack up /var/lib/docker just in case and then delete its contents:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo cp -au /var/lib/docker /var/lib/docker.bk\n$ sudo rm -rf /var/lib/docker/*\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eCreate a ZFS-backed mountpoint at \u003ccode\u003e/var/lib/docker\u003c/code\u003e. The official docker instructions suggest making a zpool and mounting it there, but I'll use a dataset since I already have a zpool configured (name \u003ccode\u003etank\u003c/code\u003e).\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo zfs create -o mountpoint=/var/lib/docker tank/docker\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003eTell Docker to use ZFS for its storage driver. In \u003ccode\u003e/etc/docker/daemon.json\u003c/code\u003e:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e{\n  \"storage-driver\": \"zfs\"\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003eStart docker back up and verify you're using the ZFS storage driver:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo /etc/init.d/docker start\n$ docker info\nServer:\n Containers: 0\n  Running: 0\n  Paused: 0\n  Stopped: 0\n Images: 114\n Server Version: 19.03.11\n Storage Driver: zfs\n  Zpool: tank\n  Zpool Health: ONLINE\n  Parent Dataset: tank/docker\n  Space Used By Parent: 17283463680\n  Space Available: 935802788864\n  Parent Quota: no\n  Compression: off\n Logging Driver: json-file\n Cgroup Driver: cgroupfs\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eðŸŽ‰ Done!\u003c/h1\u003e\n\u003cp\u003eNow we have a server running Debian with Docker using ZFS-backed storage. This would be a great way to put together a NAS setup using samba or NFS with a bunch of self-hosted services. I'll be using Docker to host a home assistant instance with nginx sitting in front as a reverse proxy.\u003c/p\u003e\n"},"dateString":"Sat Oct 03 2020","title":"Docker \u0026 ZFS On Debian","date":"2020-10-03 9:45:00 -0500","categories":"homelab"}]},"__N_SSG":true},"page":"/blog/[postId]","query":{"postId":"project-euler-15"},"buildId":"QIZacabeh_qi3cCzR8K9u","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-feb8a7604fa7fce626b2.js"></script><script src="/_next/static/chunks/main-b0c7974219aef92009e3.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.e2fe4ae6b85b1c7a6eb1.js" async=""></script><script src="/_next/static/chunks/54b56f31e4a63390429c9c080bc5921c15532dc8.bd079db40d49792afdb6.js" async=""></script><script src="/_next/static/chunks/pages/_app-8e54f29680ba8022333b.js" async=""></script><script src="/_next/static/chunks/9c82dd96d47f7e65c3cc5f64ff6b92c39ae32daa.1fc51c4ad0cb6bb4bd9d.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5BpostId%5D-00cea468919eec8492f5.js" async=""></script><script src="/_next/static/QIZacabeh_qi3cCzR8K9u/_buildManifest.js" async=""></script><script src="/_next/static/QIZacabeh_qi3cCzR8K9u/_ssgManifest.js" async=""></script></body></html>