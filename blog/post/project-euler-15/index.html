<!DOCTYPE html><html lang="en"><head><meta name="generator" content="React Static"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, shrink-to-fit=no"/><link rel="preload" as="script" href="/templates/styles.3592562f.js"/><link rel="preload" as="script" href="/templates/vendors~main.b60da2e7.js"/><link rel="preload" as="script" href="/main.e9e3ebf8.js"/><link rel="preload" as="style" href="/styles.9d2f3657.css"/><link rel="stylesheet" href="/styles.9d2f3657.css"/></head><body><div id="root"><div style="outline:none" tabindex="-1"><nav><div class="wrapper"><div class="header-wrapper"><div class="header-col"><a href="/"><svg class="logo-container" viewBox="0 0 12.4355 5.8209889"><g transform="translate(-1.0582919,-1.0582557)"><path class="logo" d="m 1.9843752,5.953161 3.96875,-3.9688494 2.6458334,2.6458994 1.3229163,-1.32295 2.6458331,2.6459" id="path862"></path></g></svg></a></div><div class="header-col"><a href="/about">About</a><a href="/blog">Blog</a></div></div></div></nav><div class="content"><div class="wrapper"><div style="outline:none" tabindex="-1"><div><div class="backline"><a href="/blog/"><h1>&lt;</h1></a><h1>Project Euler Problem #15</h1></div><br/><em>Fri Nov 13 2020</em><div><p><em>Doing the right things the wrong way.</em></p>
<h1>Intro</h1>
<p><a href="https://projecteuler.net/problem=15">Problem #15</a> from <a href="https://projecteuler.net/about">Project Euler</a> is a really interesting problem. Not only is there a clean mathematical solution to the question, but there are a <em>bunch</em> of non-optimal (or even downright ugly) but intuitive ways to solve the problem.</p>
<h1>The Easy Way</h1>
<p>The easiest, and probably fastest, way to solve this problem is to just use math. Consider the rules of the problem:</p>
<ol>
<li>Each path is composed of <em>2N</em> steps that lead from the top left to the bottom right of the domain.</li>
<li>Each step can only be a rightward or downward move.</li>
<li>Because of the start and end positions, each path must have an equal number of down and right moves.</li>
</ol>
<p>Based on these rules, you can build a valid path by starting with an empty list of <em>2N</em> steps, selecting <em>N</em> steps to place a rightward move, and filling the remaining steps with downward moves. This is a <a href="https://en.wikipedia.org/wiki/Combination">Combination Problem</a>! The number of valid paths you can possibly construct is <em>2N choose N</em>.</p>
<h1>A Fun Way</h1>
<center>
<img src="/img/treediagram.png"/>
</center>
Maybe you're itching for a reason to think about binary trees. You can look at every step in a path as a node in a binary tree. The starting position is the root node. The root node has two child nodes, one for a downward move and one for a rightward move. Each of those nodes have their own children in the same pattern. This means that two of the "grandchild" nodes actually describe different paths to the same point. In the above picture, downward moves are to the left and rightward to the right.
<p>Using this tree, we can describe any path on an infinite grid. To constrain the grid (and know when we've reached the end point), we need to add some state to each node: an x and y position: (x,y). To create a new downward node in our domain, y must be less than <em>N</em> - the new node's y value will be increased by 1. To create a new rightward node, x must be less than <em>N</em> - we'll increase the node's x. If a new node has state <em>x == N</em> and <em>y == N</em>, we've hit the end point of the grid!</p>
<p>If we actually build out this tree to full <em>2N</em> depth, we'll eat up a ton of memory. Conveniently, we don't actually need to hold all of this state since we're only interested in how many nodes in the tree are at the end point. We can just pretend to build the tree with a recursive function. Here's an implementation in RustðŸ¦€:</p>
<pre><code class="language-rust">// The size of our domain in steps
// The grid is NxN steps
// Really, our position grid is N+1xN+1
// [0,0] describes the start and [N,N] describes the end point
static N:u32 = 20;

fn build_node(x:u32, y:u32, n_ends:&#x26;mut u64) {
    // If x==y==N, we're at the end point!
    if x == N &#x26;&#x26; y == N {
        *n_ends += 1;
        return;
    }
    // Recurse for each child node if possible
    if x &#x3C; N {
        build_node(x + 1, y, n_ends);
    }
    if y &#x3C; N {
        build_node(x, y + 1, n_ends);
    }
}

fn main() {
    let mut n_ends:u64 = 0;
    // This describes the root node
    build_node(0, 0, &#x26;mut n_ends);
    println!("Total unique paths: {}", n_ends);
}
</code></pre>
<p>Go get a coffee or two, because this took ~30min to run on my machine.</p>
<p><em>Edit: This can be heavily optimized without abandoning the tree structure! More info in <a href="/blog/post/project-euler-15-addendum">this more recent post</a>.</em></p>
<h1>An ugly way</h1>
<p>Suppose you were told to solve this problem on an FPGA and you have <em>no clue</em> what combination is. Since we know the length of a path is <em>2N</em>, we'll start with a <em>2N</em>-bit wide counter. Let's say down = 1 and right = 0. We can initialize a down-counter with all 1s and let it run all the way down to 0. Since we know a valid path has #rights=#downs=<em>N</em>, we'll look at every counter value and keep track of the number of values which have exactly <em>N</em> ones. That number is the number of possible paths!</p>
<p>We can even slightly optimize this by recognizing that we only have to evalute all of the paths that start with a downward move and multiply the result by two. This follows from our tree representation above. Rust example below:</p>
<pre><code class="language-rust">// The size of our domain in steps
static N:u32 = 20;

fn main() {
    let n_ends:u64 = (2u64.pow(2*N-1)..2u64.pow(2*N)).map(|x| (x.count_ones()==N) as u64).sum();
    println!("Total unique paths: {}", 2*n_ends);
}
</code></pre>
<p>Go get another coffee. This took ~15 minutes on my machine. In the end, the mathematical solution is the way to go, but it's still fun to explore other solutions.</p>
</div><br/></div></div></div></div><footer><div class="wrapper"><div class="footer-wrapper"><div class="footer-col"><ul class="dotless-list"><li>mntn.dev</li><li>Â© Thomas Gorham 2021</li></ul></div><div class="footer-col"><ul class="dotless-list"><li><a href="/colophon">Colophon</a></li></ul></div></div></div></footer></div></div><script type="text/javascript">window.__routeInfo = JSON.parse("{\"template\":\"__react_static_root__/src/containers/Post\",\"sharedHashesByProp\":{},\"data\":{\"html\":{\"__html\":\"<p><em>Doing the right things the wrong way.</em></p>\\n<h1>Intro</h1>\\n<p><a href=\\\"https://projecteuler.net/problem=15\\\">Problem #15</a> from <a href=\\\"https://projecteuler.net/about\\\">Project Euler</a> is a really interesting problem. Not only is there a clean mathematical solution to the question, but there are a <em>bunch</em> of non-optimal (or even downright ugly) but intuitive ways to solve the problem.</p>\\n<h1>The Easy Way</h1>\\n<p>The easiest, and probably fastest, way to solve this problem is to just use math. Consider the rules of the problem:</p>\\n<ol>\\n<li>Each path is composed of <em>2N</em> steps that lead from the top left to the bottom right of the domain.</li>\\n<li>Each step can only be a rightward or downward move.</li>\\n<li>Because of the start and end positions, each path must have an equal number of down and right moves.</li>\\n</ol>\\n<p>Based on these rules, you can build a valid path by starting with an empty list of <em>2N</em> steps, selecting <em>N</em> steps to place a rightward move, and filling the remaining steps with downward moves. This is a <a href=\\\"https://en.wikipedia.org/wiki/Combination\\\">Combination Problem</a>! The number of valid paths you can possibly construct is <em>2N choose N</em>.</p>\\n<h1>A Fun Way</h1>\\n<center>\\n<img src=\\\"/img/treediagram.png\\\"/>\\n</center>\\nMaybe you're itching for a reason to think about binary trees. You can look at every step in a path as a node in a binary tree. The starting position is the root node. The root node has two child nodes, one for a downward move and one for a rightward move. Each of those nodes have their own children in the same pattern. This means that two of the \\\"grandchild\\\" nodes actually describe different paths to the same point. In the above picture, downward moves are to the left and rightward to the right.\\n<p>Using this tree, we can describe any path on an infinite grid. To constrain the grid (and know when we've reached the end point), we need to add some state to each node: an x and y position: (x,y). To create a new downward node in our domain, y must be less than <em>N</em> - the new node's y value will be increased by 1. To create a new rightward node, x must be less than <em>N</em> - we'll increase the node's x. If a new node has state <em>x == N</em> and <em>y == N</em>, we've hit the end point of the grid!</p>\\n<p>If we actually build out this tree to full <em>2N</em> depth, we'll eat up a ton of memory. Conveniently, we don't actually need to hold all of this state since we're only interested in how many nodes in the tree are at the end point. We can just pretend to build the tree with a recursive function. Here's an implementation in Rust\uD83E\uDD80:</p>\\n<pre><code class=\\\"language-rust\\\">// The size of our domain in steps\\n// The grid is NxN steps\\n// Really, our position grid is N+1xN+1\\n// [0,0] describes the start and [N,N] describes the end point\\nstatic N:u32 = 20;\\n\\nfn build_node(x:u32, y:u32, n_ends:&#x26;mut u64) {\\n    // If x==y==N, we're at the end point!\\n    if x == N &#x26;&#x26; y == N {\\n        *n_ends += 1;\\n        return;\\n    }\\n    // Recurse for each child node if possible\\n    if x &#x3C; N {\\n        build_node(x + 1, y, n_ends);\\n    }\\n    if y &#x3C; N {\\n        build_node(x, y + 1, n_ends);\\n    }\\n}\\n\\nfn main() {\\n    let mut n_ends:u64 = 0;\\n    // This describes the root node\\n    build_node(0, 0, &#x26;mut n_ends);\\n    println!(\\\"Total unique paths: {}\\\", n_ends);\\n}\\n</code></pre>\\n<p>Go get a coffee or two, because this took ~30min to run on my machine.</p>\\n<p><em>Edit: This can be heavily optimized without abandoning the tree structure! More info in <a href=\\\"/blog/post/project-euler-15-addendum\\\">this more recent post</a>.</em></p>\\n<h1>An ugly way</h1>\\n<p>Suppose you were told to solve this problem on an FPGA and you have <em>no clue</em> what combination is. Since we know the length of a path is <em>2N</em>, we'll start with a <em>2N</em>-bit wide counter. Let's say down = 1 and right = 0. We can initialize a down-counter with all 1s and let it run all the way down to 0. Since we know a valid path has #rights=#downs=<em>N</em>, we'll look at every counter value and keep track of the number of values which have exactly <em>N</em> ones. That number is the number of possible paths!</p>\\n<p>We can even slightly optimize this by recognizing that we only have to evalute all of the paths that start with a downward move and multiply the result by two. This follows from our tree representation above. Rust example below:</p>\\n<pre><code class=\\\"language-rust\\\">// The size of our domain in steps\\nstatic N:u32 = 20;\\n\\nfn main() {\\n    let n_ends:u64 = (2u64.pow(2*N-1)..2u64.pow(2*N)).map(|x| (x.count_ones()==N) as u64).sum();\\n    println!(\\\"Total unique paths: {}\\\", 2*n_ends);\\n}\\n</code></pre>\\n<p>Go get another coffee. This took ~15 minutes on my machine. In the end, the mathematical solution is the way to go, but it's still fun to explore other solutions.</p>\\n\"},\"post\":{\"fname\":\"project-euler-15.md\",\"data\":{\"title\":\"Project Euler Problem #15\",\"date\":\"2020-11-13 17:00:00 -0500\",\"categories\":\"code\"},\"md\":\"<p><em>Doing the right things the wrong way.</em></p>\\n<h1>Intro</h1>\\n<p><a href=\\\"https://projecteuler.net/problem=15\\\">Problem #15</a> from <a href=\\\"https://projecteuler.net/about\\\">Project Euler</a> is a really interesting problem. Not only is there a clean mathematical solution to the question, but there are a <em>bunch</em> of non-optimal (or even downright ugly) but intuitive ways to solve the problem.</p>\\n<h1>The Easy Way</h1>\\n<p>The easiest, and probably fastest, way to solve this problem is to just use math. Consider the rules of the problem:</p>\\n<ol>\\n<li>Each path is composed of <em>2N</em> steps that lead from the top left to the bottom right of the domain.</li>\\n<li>Each step can only be a rightward or downward move.</li>\\n<li>Because of the start and end positions, each path must have an equal number of down and right moves.</li>\\n</ol>\\n<p>Based on these rules, you can build a valid path by starting with an empty list of <em>2N</em> steps, selecting <em>N</em> steps to place a rightward move, and filling the remaining steps with downward moves. This is a <a href=\\\"https://en.wikipedia.org/wiki/Combination\\\">Combination Problem</a>! The number of valid paths you can possibly construct is <em>2N choose N</em>.</p>\\n<h1>A Fun Way</h1>\\n<center>\\n<img src=\\\"/img/treediagram.png\\\"/>\\n</center>\\nMaybe you're itching for a reason to think about binary trees. You can look at every step in a path as a node in a binary tree. The starting position is the root node. The root node has two child nodes, one for a downward move and one for a rightward move. Each of those nodes have their own children in the same pattern. This means that two of the \\\"grandchild\\\" nodes actually describe different paths to the same point. In the above picture, downward moves are to the left and rightward to the right.\\n<p>Using this tree, we can describe any path on an infinite grid. To constrain the grid (and know when we've reached the end point), we need to add some state to each node: an x and y position: (x,y). To create a new downward node in our domain, y must be less than <em>N</em> - the new node's y value will be increased by 1. To create a new rightward node, x must be less than <em>N</em> - we'll increase the node's x. If a new node has state <em>x == N</em> and <em>y == N</em>, we've hit the end point of the grid!</p>\\n<p>If we actually build out this tree to full <em>2N</em> depth, we'll eat up a ton of memory. Conveniently, we don't actually need to hold all of this state since we're only interested in how many nodes in the tree are at the end point. We can just pretend to build the tree with a recursive function. Here's an implementation in Rust\uD83E\uDD80:</p>\\n<pre><code class=\\\"language-rust\\\">// The size of our domain in steps\\n// The grid is NxN steps\\n// Really, our position grid is N+1xN+1\\n// [0,0] describes the start and [N,N] describes the end point\\nstatic N:u32 = 20;\\n\\nfn build_node(x:u32, y:u32, n_ends:&#x26;mut u64) {\\n    // If x==y==N, we're at the end point!\\n    if x == N &#x26;&#x26; y == N {\\n        *n_ends += 1;\\n        return;\\n    }\\n    // Recurse for each child node if possible\\n    if x &#x3C; N {\\n        build_node(x + 1, y, n_ends);\\n    }\\n    if y &#x3C; N {\\n        build_node(x, y + 1, n_ends);\\n    }\\n}\\n\\nfn main() {\\n    let mut n_ends:u64 = 0;\\n    // This describes the root node\\n    build_node(0, 0, &#x26;mut n_ends);\\n    println!(\\\"Total unique paths: {}\\\", n_ends);\\n}\\n</code></pre>\\n<p>Go get a coffee or two, because this took ~30min to run on my machine.</p>\\n<p><em>Edit: This can be heavily optimized without abandoning the tree structure! More info in <a href=\\\"/blog/post/project-euler-15-addendum\\\">this more recent post</a>.</em></p>\\n<h1>An ugly way</h1>\\n<p>Suppose you were told to solve this problem on an FPGA and you have <em>no clue</em> what combination is. Since we know the length of a path is <em>2N</em>, we'll start with a <em>2N</em>-bit wide counter. Let's say down = 1 and right = 0. We can initialize a down-counter with all 1s and let it run all the way down to 0. Since we know a valid path has #rights=#downs=<em>N</em>, we'll look at every counter value and keep track of the number of values which have exactly <em>N</em> ones. That number is the number of possible paths!</p>\\n<p>We can even slightly optimize this by recognizing that we only have to evalute all of the paths that start with a downward move and multiply the result by two. This follows from our tree representation above. Rust example below:</p>\\n<pre><code class=\\\"language-rust\\\">// The size of our domain in steps\\nstatic N:u32 = 20;\\n\\nfn main() {\\n    let n_ends:u64 = (2u64.pow(2*N-1)..2u64.pow(2*N)).map(|x| (x.count_ones()==N) as u64).sum();\\n    println!(\\\"Total unique paths: {}\\\", 2*n_ends);\\n}\\n</code></pre>\\n<p>Go get another coffee. This took ~15 minutes on my machine. In the end, the mathematical solution is the way to go, but it's still fun to explore other solutions.</p>\\n\",\"stripped\":\"project-euler-15\"}},\"path\":\"blog/post/project-euler-15\",\"sharedData\":{},\"siteData\":{}}");</script><script defer="" type="text/javascript" src="/templates/styles.3592562f.js"></script><script defer="" type="text/javascript" src="/templates/vendors~main.b60da2e7.js"></script><script defer="" type="text/javascript" src="/main.e9e3ebf8.js"></script></body></html>